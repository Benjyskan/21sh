Each lines has a struct corresponding to it.
The input_cmd is a list of those structs.

A chained list of cmd_line structs. Doubly linked (move up and down);
Data we need :
	window size;
	starting position
	char *cmd_line
	current_malloc_size;
	current_data_size;
	line_pointer;
	nb_lines;

When writing on a cmd_line : normal rules, except when printing a
newline (position == ws->columns)
nb_lines = ft_strlen(cmd_line) / ws->columns
current_cursor_pos.row = cmd_line.start_pos.row + (line_pointer / ws->columns)
current_cursor_pos.columns = line_pointer % ws->columns;
case where start pos is before terminal (negative)
prompt_size


util function to place cursor according to line_pointer

s a l u t \t
1 1 1 1 1 4

each line is a : chained list of structs that contain a char* and a disp_size
read byte per byte
disp_size = read, write, check if we have moved. Does not work with tabs.


struct global_input
	struct window	window_size;
	t_pos			starting_position;
	struct t_line	**line;

struct s_line
	char			*data;
	int				disp_size;
	t_bool			selected;
	struct s_line	*next;
	struct s_line	*prev;

in the end, simply append all s_lines->data
